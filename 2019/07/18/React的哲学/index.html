<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>React 的哲学 | Lijinming</title><meta name="description" content="React 的哲学"><meta name="keywords" content="JSX,React"><meta name="author" content="Lijinming"><meta name="copyright" content="Lijinming"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/07/18/React的哲学/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="React 的哲学"><meta name="twitter:description" content="React 的哲学"><meta name="twitter:image" content="http://www.yosamstep.cn/2019/07/18/React的哲学/云南丽江.jpg"><meta property="og:type" content="article"><meta property="og:title" content="React 的哲学"><meta property="og:url" content="http://yoursite.com/2019/07/18/React的哲学/"><meta property="og:site_name" content="Lijinming"><meta property="og:description" content="React 的哲学"><meta property="og:image" content="http://www.yosamstep.cn/2019/07/18/React的哲学/云南丽江.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="Js的提升机制" href="http://yoursite.com/2019/09/06/Js的提升机制/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Bookmark',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days'

  
}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JSX"><span class="toc-number">1.</span> <span class="toc-text">JSX</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是JSX？"><span class="toc-number">1.1.</span> <span class="toc-text">什么是JSX？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要用JSX？"><span class="toc-number">1.2.</span> <span class="toc-text">为什么要用JSX？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数式编程"><span class="toc-number">2.</span> <span class="toc-text">函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#声明式编程"><span class="toc-number">2.1.</span> <span class="toc-text">声明式编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数优先"><span class="toc-number">2.2.</span> <span class="toc-text">函数优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#纯函数"><span class="toc-number">2.3.</span> <span class="toc-text">纯函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#函数的副作用"><span class="toc-number">2.3.1.</span> <span class="toc-text">函数的副作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引用透明"><span class="toc-number">2.3.2.</span> <span class="toc-text">引用透明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参数值不可变"><span class="toc-number">2.3.3.</span> <span class="toc-text">参数值不可变</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟DOM"><span class="toc-number">3.</span> <span class="toc-text">虚拟DOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组件化"><span class="toc-number">4.</span> <span class="toc-text">组件化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#特征"><span class="toc-number">4.1.</span> <span class="toc-text">特征</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单向数据流"><span class="toc-number">5.</span> <span class="toc-text">单向数据流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单向数据流过程"><span class="toc-number">5.1.</span> <span class="toc-text">单向数据流过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特点"><span class="toc-number">5.2.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结语"><span class="toc-number">6.</span> <span class="toc-text">结语</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://www.yosamstep.cn/2019/07/18/React的哲学/云南丽江.jpg)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">Lijinming</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><div class="menu_mask"></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" src="/img/love.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item text-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">2</div></a></div></div><div class="mobile_data_item text-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">3</div></a></div></div><div class="mobile_data_item text-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">2</div></a></div></div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首頁</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分页</span></a><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title"><div class="posttitle">React 的哲学</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2019-07-18<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> Updated 2019-08-30</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/React/">React</a></span></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><blockquote>
<p>我们认为，React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。它在 Facebook 和 Instagram 上表现优秀。<br>参考文章（<a href="https://zh-hans.reactjs.org/docs/thinking-in-react.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/thinking-in-react.html</a>）</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在学习了一段时间的 React 后，我发现 React 有一种魔力（笔者对 Vue 和 Angular 了解甚少，各有各的好啊），就是不论什么页面需求，我们都能够通过 React，直观的感受到我们应该如何去实现它，从设计功能到维护，清晰明确。在我看来这是 React 的哲学，接下来就让我们看看它到底和原生 JavaScript 或者其他框架或者库有什么不同之处，它究竟好用在哪里？</p>
<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><h3 id="什么是JSX？"><a href="#什么是JSX？" class="headerlink" title="什么是JSX？"></a>什么是JSX？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们先来看一个简单的变量声明：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</span><br></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这对于没学过 JSX 的同学来说看起来有点玄幻，并打出了黑人问号<em>（这TM是HTML吗？为啥这个变量的值是 HTML 啊？那这个 element 属于什么类型啊？字符串吗……）</em><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>这个有趣的标签语法既不是字符串也不是 HTML。</strong></p>
<blockquote>
<p>它被称为 JSX，是一个 JavaScript 的语法扩展。我们建议在 React 中配合使用 JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。</p>
</blockquote>
<h3 id="为什么要用JSX？"><a href="#为什么要用JSX？" class="headerlink" title="为什么要用JSX？"></a>为什么要用JSX？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们来近距离接触一下一段输出 Hello World! 的 React 代码</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1 className=<span class="string">'Title'</span>&gt;Hello World!&lt;/h1&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;Header /</span>&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们想在原生 JavaScript 中写 HTML，我们就需要不断的创造 DOM 对象，结构不清晰，冗余且不能一目了然的看清楚 DOM 结构。 于是我们把 JavaScript 的语法扩展了一下，让 JavaScript 语言能够支持这种直接在 JavaScript 代码里面编写类似 HTML 标签结构的语法，这样看起来就方便多了。</p>
<blockquote>
<p>1.React 认为<strong>渲染逻辑</strong>本质上与其他 <strong>UI</strong> 逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI，以及需要在 UI 中展示准备好的数据。<br>2.React 并没有采用将<strong>标记与逻辑</strong>进行分离到不同文件这种人为地分离方式，而是通过将二者共同存放在称之为<strong>“组件”</strong>的松散耦合单元之中，来实现关注点分离。<br>3.React <strong>不强制要求使用 JSX</strong>，但是大多数人发现，在 JavaScript 代码中将 JSX 和 UI 放在一起时，会在视觉上有辅助作用。它还可以使 React 显示更多有用的错误和警告消息。<br>参考文章 <a href="https://react.docschina.org/docs/introducing-jsx.html" target="_blank" rel="noopener">链接</a> </p>
</blockquote>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>函数式编程（Functional Programming）是React的灵魂，了解了函数式编程有助于更好的理解React的特点。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数式编程不是一种新的框架或工具，而是一种以函数为主的编程范式。编程范式也叫编程范型，是一类编程风格，除了函数式编程，常用的还有面向对象编程、命令式编程等。</p>
<h3 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;声明式编程也是一种范式，但它是一个比较大的概念，函数式编程是它的一个子集。声明式编程能指定每一步操作，而不用向计算机描述具体的实现细节。与之相对立的是命令式编程，它会命令计算机每一步该怎么做。以数组的元素翻倍为例，先用命令式编程进行实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  length = arr.length,</span><br><span class="line">  doubles = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">  doubles.push(arr[i] * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在命令式的代码中，先用for循环遍历整个数组，然后让每个元素乘以二，再将计算结果插入到 doubles 数组中，直至将所有的元素计算完才终止整套操作。改用声明式编程可以像下面这样实现相同的功能。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> doubles = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">value</span> =&gt;</span> value * <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在声明式的代码中，用 map() 方法替代了循环语句（即不指明流程的控制方式），既不用再维护计数器，也不用再通过索引访问数组的元素，配合 ES6 的箭头函数让整套操作变得非常简洁。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了这些表面区别之外，还有个最本质的区别，那就是声明式编程会避免用变量保存程序的状态，从而能提高代码的无状态性。在命令式的代码中，每次迭代都会修改 doubles 变量，这是个状态变量，而在声明式的代码中，改用返回值保存程序的状态。</p>
<h3 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数式编程强调在程序中使用函数。由于 JavaScript 中的函数是一等公民，它既可以是变量的值，也可以作为另一函数的参数或返回值，因此通过函数可构建一层抽象以替代流程控制或解决复杂的逻辑操作。例如对数组中的数字进行排序和过滤，可以像下面这样运用函数式编程的思想实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>].sort().filter(<span class="function"><span class="params">value</span> =&gt;</span> value &gt; <span class="number">2</span>);        <span class="comment">//[3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数式编程旨在将复杂的运算分解成一系列嵌套的函数，逐层推导，不断渐进，直至完成运算，这也是React组合的思想。</p>
<h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;纯函数（Pure Function）是一种没有副作用、引用透明的函数，它是函数式编程的基本概念，接下来会重点讲解它的三个特征。</p>
<h4 id="函数的副作用"><a href="#函数的副作用" class="headerlink" title="函数的副作用"></a>函数的副作用</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数在读写外部资源或执行不确定的操作时就会产生副作用，例如修改函数外的变量、调用 Date.now()或 Math.random()、更新cookie信息等。副作用不仅会降低程序整体的可读性，有时候还会带来意料之外、难以排查的错误，下面是一个副作用的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> digit = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  digit += <span class="built_in">Math</span>.random();</span><br><span class="line">  <span class="keyword">return</span> digit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的代码中，increment()函数产生了副作用，因为每次调用它都会更新外部的digit变量，并且每次得到的计算结果也无法预知。</p>
<h4 id="引用透明"><a href="#引用透明" class="headerlink" title="引用透明"></a>引用透明</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果传递给函数相同的参数，始终能得到相同的结果，那么就能说这个函数是引用透明（Referential Transparent）的。简单的说就是，函数的运行只受其输入值的影响，如下代码所示，传递给add()函数固定的参数会返回固定的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参数值不可变"><a href="#参数值不可变" class="headerlink" title="参数值不可变"></a>参数值不可变</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传递给纯函数的参数值是不允许在内部将其改变的，换句话说，在函数内部使用的是参数值的副本。<strong>如果参数值是基本类型的，那么传递给函数的就是其副本；但如果参数值是对象类型的，那么需要注意，传递给函数的是引用对象的指针。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面用一个示例说明，addDigit()函数的参数是一个数组，它的功能是为数组的每个元素加一，在执行addDigit(digits)之后，由于digits变量是一个数组，因此它的元素会随着函数的调用而被改变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> digits = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addDigit</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">    arr[i] += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">addDigit(digits);</span><br><span class="line"><span class="built_in">console</span>.log(digits);       <span class="comment">//[2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来修改addDigit()函数，使之能满足纯函数的要求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> digits = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addDigit</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.map(<span class="function"><span class="params">value</span> =&gt;</span> value + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">addDigit(digits);</span><br><span class="line"><span class="built_in">console</span>.log(digits);       <span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在addDigit()函数内部，用map()方法替代for循环，使得在不改变参数的前提下，完成元素加一的功能。</p>
<h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虚拟DOM( Virtual DOM )是一个模拟 DOM 树的 JavaScript 对象。 <strong>React 使用 Virtual DOM 来渲染 UI，当组件状态 state 有更改的时候，React 会自动调用组件的 render 方法重新渲染整个组件的 UI</strong> 。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;React 主要的目标是提供一套不同的, 高效的方案来更新 DOM。这不是直接的获取 DOM 进行一次次的操作, 而是通过构建 “ Virtual DOM ”, 虚拟的 DOM, 随后 React 处理真实的 DOM 上的更新来进行模拟相应的更新。</p>
<p><img alt="Virtual DOM" data-src="/2019/07/18/React的哲学/VirtualDOM.png" class="lozad"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们再额外的加了一层 DOM，为什么更快了呢?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于虚拟 DOM 的很多演讲和文章都指出，尽管现在 javascript 的引擎已经很快了，但是读取和写入浏览器的 DOM 还是很慢，<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这不是特别的准确。 <strong>DOM 是很快的。增加和去除 DOM 节点就是设置一些 javascript 对象的属性，这才是简单的操作，这并不是需要做很多的工作</strong> 。<strong>真正慢的地方自在于，每次 DOM 改变的时候，都需要在浏览器中进行渲染。每一次 DOM 改变的时候，浏览器都需要重新计算 CSS，进行布局处理，然后重新渲染页面。这都需要时间。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;浏览器的开发者持续不断的工作来缩短渲染页面的时间。最关键的需要完成的事情是最小化 DOM 改变，然后批处理 DOM 变化，在必要的时候才重新渲染页面。（目前原生浏览器还是无法做到）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种批处理 DOM 改变的策略，把我们提升到了一个更加抽象的层次，这也是 React 虚拟 DOM 背后的 idea。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Virtual DOM 和真实的 DOM 有着不用的语义, 但同时也有明显不同的 API。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOM 树上的节点被称为元素, 而 virtual DOM 是完全不同的抽象, 叫做 <code>components</code> 。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component 的使用在 React 里极为重要, 因为 <code>components</code> 的存在让计算 DOM diff 更高效。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单的说就是：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果大面积的操作 DOM 并且更新频率很快，性能会是一个很大的问题，所以 React 实现了一个虚拟 DOM，组件 DOM 结构映射到这个虚拟 DOM 上，React 在这个虚拟 DOM 上实现了一个 diff 算法，当要更新组件的时候，会通过 diff 寻找到要变更的 DOM 节点，再把这个修改更新到浏览器实际的 DOM 节点上，所以实际上不是真的渲染整个 DOM 树。这个虚拟 DOM 是一个纯粹的 JS 数据结构，所以性能会比原生 DOM 快很多。</p>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虚拟 DOM 不仅带来了简单的 UI 开发逻辑，同时也带来了组件化开发的思想，所谓组件，即封装起来的具有独立功能的 UI 部件。 React 推荐以组件的方式去重新思考 UI 构成，将 UI 上每一个功能相对独立的模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成大的组件，最终完成整体 UI 的构建。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果说 MVC 的思想让你做到视图-数据-控制器的分离，那么组件化的思考方式则是带来了 UI 功能模块之间的分离。我们通过一个典型的 Blog 评论界面来看 MVC 和组件化开发思路的区别。</p>
<p><img alt="Blog评论页面组件化流程" data-src="/2019/07/18/React的哲学/Component1.png" class="lozad"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 MVC 开发模式来说，开发者将三者定义成不同的类，实现了表现，数据，控制的分离。开发者更多的是从技术的角度来对UI进行拆分，实现松耦合。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 React 而言，则完全是一个新的思路，开发者从功能的角度出发，将UI分成不同的组件，每个组件都独立封装。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 React 中，你按照界面模块自然划分的方式来组织和编写你的代码，对于评论界面而言，整个 UI 是一个通过小组件构成的大组件，每个组件只关心自己部分的逻辑，彼此独立。</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;React认为一个组件应该具有如下特征：</p>
<ol>
<li><p>可组合（Composeable）：一个组件易于和其它组件一起使用，或者嵌套在另一个组件内部。如果一个组件内部创建了另一个组件，那么说父组件拥有（own）它创建的子组件，通过这个特性，一个复杂的 UI 可以拆分成多个简单的 UI 组件；</p>
</li>
<li><p>可重用（Reusable）：每个组件都是具有独立功能的，它可以被使用在多个 UI 场景；</p>
</li>
<li><p>可维护（Maintainable）：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护；</p>
</li>
</ol>
<h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们先来看一下“单向数据流”理念的极简示意：</p>
<p><img alt="state：驱动应用的数据源。 view：以声明方式将 state 映射到视图 。 actions：响应在 view 上的用户输入导致的状态变化" data-src="/2019/07/18/React的哲学/SingleDataWorkFlow1.png" class="lozad"></p>
<h3 id="单向数据流过程"><a href="#单向数据流过程" class="headerlink" title="单向数据流过程"></a>单向数据流过程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单的单向数据流（unidirectional data flow）是指用户访问View，View发出用户交互的Action，在Action里对state进行相应更新。state更新后会触发View更新页面的过程。这样数据总是清晰的单向进行流动，便于维护并且可以预测。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>所有状态的改变可记录、可跟踪，源头易追溯;</li>
<li>所有数据只有一份，组件数据只有唯一的入口和出口，使得程序更直观更容易理解，有利于应用的可维护性;</li>
<li>一旦数据变化，就去更新页面(data-页面)，但是没有(页面-data);</li>
<li>如果用户在页面上做了变动，那么就手动收集起来(双向是自动)，合并到原有的数据中。</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><ul>
<li>React 通过采用声明范式可以轻松描述应用。 </li>
<li>JSX 是 JavaScript 语法的扩展， React 建议使用 JSX 进行开发。 </li>
<li>React 通过对 DOM 的模拟，最大限度地减少与 DOM 的交互。 </li>
<li>React 可以与已知的库或框架很好地配合。</li>
<li>通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。</li>
<li>单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Lijinming</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/07/18/React的哲学/">http://yoursite.com/2019/07/18/React的哲学/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JSX/">JSX    </a><a class="post-meta__tags" href="/tags/React/">React    </a></div><div class="post_share"><div class="social-share" data-image="http://www.yosamstep.cn/2019/07/18/React的哲学/云南丽江.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-full"><a href="/2019/09/06/Js的提升机制/"><img class="prev_cover lozad" data-src="https://picsum.photos/id/744/1920/1080" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>Js的提升机制</span></div></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By Lijinming</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><a id="to_comment" href="#post-comment"><i class="scroll_to_comment fa fa-comments"></i></a><i class="fa fa-book" id="readmode" title="Read Mode"> </i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion">繁</a><i class="fa fa-moon-o nightshift" id="nightshift" title="Dark Mode"></i></section><div id="post_bottom"><div id="post_bottom_items"><a id="mobile_to_comment" href="#post-comment"><i class="mobile_scroll_to_comment fa fa-comments"></i></a><i class="fa fa-list" id="mobile_toc"></i><div id="toc_mobile"><div class="toc_mobile_headline">Catalog</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#JSX"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">JSX</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#什么是JSX？"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">什么是JSX？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#为什么要用JSX？"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">为什么要用JSX？</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#函数式编程"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">函数式编程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#声明式编程"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">声明式编程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#函数优先"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">函数优先</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#纯函数"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">纯函数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#函数的副作用"><span class="toc_mobile_items-number">2.3.1.</span> <span class="toc_mobile_items-text">函数的副作用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#引用透明"><span class="toc_mobile_items-number">2.3.2.</span> <span class="toc_mobile_items-text">引用透明</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#参数值不可变"><span class="toc_mobile_items-number">2.3.3.</span> <span class="toc_mobile_items-text">参数值不可变</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#虚拟DOM"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">虚拟DOM</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#组件化"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">组件化</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#特征"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">特征</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#单向数据流"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">单向数据流</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#单向数据流过程"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">单向数据流过程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#特点"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">特点</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#结语"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">结语</span></a></li></ol></div></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zindex="-1" data-click="false"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();</script></body></html>